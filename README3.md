# Вычислительные характеристики алгоритмов сортировки и поиска

Данный документ подготовлен в рамках выполнения практической работы по темам 3.1–3.5 и содержит анализ трудоёмкости (временной сложности) основных алгоритмов сортировки и поиска, предусмотренных методическими указаниями.

---

## 1. Сортировка выбором (Selection Sort)

### Основная идея
На каждом шаге из неотсортированной части массива выбирается минимальный элемент и меняется местами с первым элементом этой части.

### Особенности выполнения
- Внешний цикл выполняется `n − 1` раз.
- Внутренний цикл ищет минимальный элемент в оставшемся фрагменте.
- После нахождения — обмен с текущим элементом.

### Трудоёмкость
- **Худший / средний / лучший случаи:** `O(n²)`  
- **Обоснование:** Общее число сравнений — `n(n − 1)/2`, что даёт квадратичную зависимость от размера массива.

---

## 2. Сортировка обменом (пузырёк, Bubble Sort)

### Основная идея
Многократные проходы по массиву с попарным сравнением соседних элементов и их обменом при нарушении порядка.

### Особенности выполнения
- На каждом проходе наибольший элемент «всплывает» в конец.
- Внешний цикл — `n − 1` проходов.
- Внутренний цикл на `i`-й итерации делает `n − i − 1` сравнений.
- При отсутствии обменов можно завершить досрочно.

### Трудоёмкость
- **Худший / средний случаи:** `O(n²)`  
- **Лучший случай (массив уже отсортирован):** `O(n)`  
- **Обоснование:** В худшем случае — `n(n − 1)/2` сравнений и до `3·n(n − 1)/2` операций присваивания.

---

## 3. Сортировка вставками (Insertion Sort)

### Основная идея
Постепенное расширение отсортированной части массива за счёт вставки каждого следующего элемента в нужную позицию.

### Особенности выполнения
- Первый элемент считается отсортированным.
- Начиная со второго, каждый элемент сравнивается с предыдущими и сдвигается, пока не найдёт своё место.
- Используется временная переменная для хранения вставляемого значения.

### Трудоёмкость
- **Худший / средний случаи:** `O(n²)`  
- **Лучший случай:** `O(n)`  
- **Обоснование:** В худшем случае требуется `n(n − 1)/2` сравнений и почти столько же сдвигов.

---

## 4. Сортировка слиянием (Merge Sort)

### Основная идея
Рекурсивное деление массива пополам до единичных элементов с последующим слиянием отсортированных частей.

### Особенности выполнения
- Применяется стратегия «разделяй и властвуй».
- Требуется дополнительная память для временных массивов.
- Процедура `merge` объединяет два упорядоченных подмассива за линейное время.

### Трудоёмкость
- **Все случаи:** `Θ(n log n)`  
- **Обоснование:** Глубина рекурсии — `log₂ n`, на каждом уровне обрабатывается `n` элементов.
- **Пространственная сложность:** `O(n)`

---

## 5. Сортировка Шелла (Shell Sort)

### Основная идея
Модификация сортировки вставками, при которой элементы сравниваются и перемещаются с шагом (gap), который постепенно уменьшается до 1.

### Особенности выполнения
- Используется последовательность шагов (в методичке — `n/2, n/4, ..., 1`).
- На каждом шаге выполняется сортировка вставками по подпоследовательностям.
- Число проходов — `O(log n)`.

### Трудоёмкость
- **Зависит от последовательности шагов:**
  - Для классической: `O(n²)`
  - Для последовательности Кнута: `O(n^(3/2))`
- **Обоснование:** Эффективность определяется тем, насколько быстро уменьшается число инверсий.

---

## 6. Быстрая сортировка (Quick Sort)

### Основная идея
Выбор опорного элемента и разделение массива на две части: элементы меньше опоры — слева, больше — справа. Далее — рекурсивная сортировка подмассивов.

### Особенности выполнения
- Процедура `partition` перестраивает массив за `O(n)`.
- Глубина рекурсии зависит от баланса разбиения.
- В методичке используется последний элемент как опора.

### Трудоёмкость
- **Средний случай:** `O(n log n)`  
- **Худший случай (например, отсортированный массив):** `O(n²)`  
- **Обоснование:** При неудачном выборе опоры разбиение становится вырожденным.

---

## 7. Пирамидальная сортировка (Heapsort)

### Основная идея
Построение max-heap из массива, затем последовательное извлечение максимального элемента и его перемещение в конец.

### Особенности выполнения
- Первый этап — построение кучи за `O(n)`.
- Второй этап — `n − 1` извлечений с восстановлением кучи (`O(log n)` на операцию).
- Работает in-place.

### Трудоёмкость
- **Все случаи:** `Θ(n log n)`  
- **Обоснование:** Каждое извлечение требует `log n` операций, всего `n` извлечений.

---

## 8. Последовательный (линейный) поиск

### Основная идея
Перебор элементов массива по порядку с сравнением каждого с искомым значением.

### Особенности выполнения
- Работает с неотсортированными данными.
- Прост в реализации.
- Гарантированно находит элемент, если он есть.

### Трудоёмкость
- **Все случаи:** `O(n)`  
- **Пространственная сложность:** `O(1)`

---

## 9. Бинарный (дихотомический) поиск

### Основная идея
Поиск в отсортированном массиве путём многократного деления области поиска пополам.

### Особенности выполнения
- Требует предварительной сортировки.
- На каждой итерации сравнивается средний элемент с искомым.
- Границы поиска корректируются в зависимости от результата сравнения.

### Трудоёмкость
- **Худший / средний случаи:** `O(log n)`  
- **Лучший случай:** `O(1)`  
- **Обоснование:** Размер области поиска уменьшается вдвое на каждом шаге.

---

## 10. Интерполирующий поиск

### Основная идея
Уточнённый поиск в отсортированном массиве с использованием формулы линейной интерполяции для оценки позиции искомого элемента.

### Формула позиции:
